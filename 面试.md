# 基础知识

## 1.基本语言（1）

### 1.1说一下static关键字的作用

**\1. 全局静态变量**

在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.

内存中的位置：静态存储区，在整个程序运行期间一直存在。

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

**\2.  局部静态变量**

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

内存中的位置：静态存储区

初始化：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。==但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；==

**\3. 静态函数**

在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，**但静态函数只是在声明他的文件当中可见，不能被其他文件所用。**

==函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；==

**warning：**不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

**\4. 类的静态成员**

在类中，**静态成员可以实现多个对象之间的数据共享**，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用

**\5. 类的静态函数**

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

**在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）**。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

### 1.2说一下C和C++的区别

**设计思想上：**

C++是面向对象的语言，而C是面向过程的结构化编程语言

**语法上：**

C++具有封装、继承和多态三种特性

C++相比C，增加多许多**类型安全**的功能，比如强制类型转换、

C++支持**范式编程**，比如模板类、函数模板等

### 1.3说一下C++中static关键字的作用

对于**函数定义和代码块之外的变量声明（全局）**，**static修改标识符的链接属性**，由默认的external变为internal([示例详解](https://blog.csdn.net/ljz2009y/article/details/8142653)），作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。

对于**代码块内部的变量声明（局部）**，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。==这种变量在程序执行之前就创建，在程序执行的整个周期都存在。==

对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用

对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。

1.加了static关键字的全局变量只能在本文件中使用。例如在a.c中定义了static int a=10;那么在b.c中用extern int a是拿不到a的值得，a的作用域只在a.c中。
 2.static定义的静态局部变量分配在数据段上，普通的局部变量分配在栈上，会因为函数栈帧的释放而被释放掉。3.对一个类中成员变量和成员函数来说，加了static关键字，则此变量/函数就没有了this指针了，必须通过类名才能访问

### 1.4说一次c++四种cast转换

**C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast**

**1、const_cast**：

用于将const变量转为非const

**2、static_cast：**

用于各种**隐式转换**，比如非const转const，void*转指针等, static_cast能用于多态向上（小范围->大范围)转化，如果向下转能成功但是不安全，结果未知；

**3、dynamic_cast**:

用于动态类型转换。**只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用**。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。

向上转换：指的是子类向基类的转换

向下转换：指的是基类向子类的转换

它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

**4、reinterpret_cast**

几乎什么都可以转，比如将**int转指针**，可能会出问题，尽量少用；

**5、为什么不使用C的强制转换？**

C的强制转换表面上看起来功能强大什么都能转，但是**转化不够明确，不能进行错误检查，容易出错。**

### 1.5请说一下C/C++ 中指针和引用的区别？

**定义：**

**1、引用**

C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：`类型标识符 &引用名=目标变量名；`引用引入了对象的一个同义词。定义引用的表示方法与定义[指针](https://baike.baidu.com/item/指针/2878304)相似，只是用&代替了*。

**2、指针**

指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。

**区别：**

1.指针有自己的一块空间，而引用只是一个别名；

2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；

3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；

4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；

5.可以有const指针，但是没有const引用；

6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；

7.指针可以有多级指针（\**p），**而引用只有一级；**

8.指针和引用使用++运算符的意义不一样；

9.如果返回动态内存分配的对象或者内存，必须使用指针，**引用可能引起内存泄露**。

### 1.6给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内，给出思路并手写代码

```c++
/*根据面积法，如果P在三角形ABC内，那么三角形ABP的面积+三角形BCP的面积+三角形ACP的面积应该等于三角形ABC的面积。算法如下：*/
#include <iostream>
#include <math.h>
using namespace std;
#define ABS_FLOAT_0 0.0001
struct point_float
{
	float x;
	float y;
};

/**
* 计算三角形面积
*/
float GetTriangleSquar(const point_float pt0, const point_float pt1, const point_float pt2)
{
	point_float AB,   BC;
	AB.x = pt1.x - pt0.x;
	AB.y = pt1.y - pt0.y;
	BC.x = pt2.x - pt1.x;
	BC.y = pt2.y - pt1.y;
	return fabs((AB.x * BC.y - AB.y * BC.x)) / 2.0f;	//fabs(x):返回x的绝对值
    /*他求三角形的两个点不够严谨，但是结果一样，三角形A(x1,y1) B(x2,y2) C(x3,y3) ，从A点发的两条边 AC=(x3-x1,y3-y1)；AB=(x2-x1,y2-y1)，三角形的面积 S=1/2( AC x AB) (利用向量 的叉乘)
    海伦公式求：
    		double a,b,c,p,Area;
			cin>>a>>b>>c;
			p=(a+b+c)/2;
			Area=sqrt(p*(p-a)*(p-b)*(p-c));*/
}

/**
* @brief 判断给定一点是否在三角形内或边上
*/
bool IsInTriangle(const point_float A, const point_float B, const point_float C, const point_float D)
{
	float SABC, SADB, SBDC, SADC;
	SABC = GetTriangleSquar(A, B, C);
	SADB = GetTriangleSquar(A, D, B);
	SBDC = GetTriangleSquar(B, D, C);
	SADC = GetTriangleSquar(A, D, C);
	float SumSuqar = SADB + SBDC + SADC;
	if ((-ABS_FLOAT_0 < (SABC - SumSuqar)) && ((SABC - SumSuqar) < ABS_FLOAT_0))
	{
		return true;
	}
	else
	{
		return false;
	}
}
```

### 1.7请你说一下你理解的c++中的smart pointer四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr

C++里面的四个智能指针: `auto_ptr, shared_ptr, weak_ptr, unique_ptr` 其中后三个是c++11支持，**并且第一个已经被11弃用。**

为什么要使用智能指针：

智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，==因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源==。所以智能指针的**作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。**

- **1. auto_ptr（c++98的方案，cpp11已经抛弃）**

采用所有权模式，把指针该有的所有权全部都拿过来 。

```c++
auto_ptr<string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr不会报错.
```

此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！

- **2. unique_ptr（替换auto_ptr）**

unique_ptr实现独占式拥有或**严格拥有概念**，保证同一时间内只有一个智能指针可以指向该对象**。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。

采用所有权模式，还是上面那个例子

```c++
unique_ptr<string> p3 (new string ("auto"));   //#4
unique_ptr<string> p4；                       //#5
p4 = p3;//此时会报错！！
```

**编译器认为p4=p3非法，**避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。

另外unique_ptr还有更聪明的地方：**当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做**，比如：

```c++
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1;                                      // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed，临时右值允许
```

其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，**unique_ptr 优于允许两种赋值的auto_ptr** 。

注：如果确实想执行类似与#1的操作，**要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。**例如：

```c++
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);	//在赋值之后，ps1的值是不确定的
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;
```

通常情况下，static_cast 只能用于其他合法的类型转换。但是有一条针对右值的特许规则：虽然不能隐式的将一个左值转换成右值引用，但我们可以用static_cast显示的将一个左值转换为一个右值。

- **3. shared_ptr**

**shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放，当然这需要额外的开销。**从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数`use_count()`来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用`release()`时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。使用方法：

```c++
//最安全的分配和使用动态内存的方法
std::shared_ptr<int> sp1=std::make_shared<int>(11);
std::shared_ptr<std::string> sp2 = std::make_shared<std::string>("Hello c++");
auto sp3 = std::make_shared<int>(11);
printf("sp3=%d\n", *sp3);
auto sp4 = std::make_shared<std::string>("C++11");
printf("sp4=%s\n", (*sp4).c_str());
```

**成员函数：**

use_count （）：返回引用计数的个数

unique （）：返回是否是独占所有权( use_count 为 1)

swap （）：交换两个 shared_ptr 对象(即交换所拥有的对象)

reset（）： 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少

get（） ：返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 ：
`shared_ptr<int> sp(new int(1));` sp 与 sp.get()是等价的。et用来将指针的访问权限传递给代码，只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值！

- **weak_ptr**

weak_ptr 是一种不控制对象生命周期的智能指针, **它指向一个 shared_ptr 管理的对象**. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。**它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。**

```c++
class B;
class A
{
public:
	shared_ptr<B> pb_;
	~A()
	{
		cout<<"A delete\n";
	}
};
class B
{
public:
	shared_ptr<A> pa_;
	~B()
	{
		cout<<"B delete\n";
	}
};
void fun()
{
	shared_ptr<B> pb(new B());
	shared_ptr<A> pa(new A());
	pb->pa_ = pa;
	pa->pb_ = pb;
	cout<<pb.use_count()<<endl;
	cout<<pa.use_count()<<endl;
}
int main()
{
	fun();
	return 0;
}
```

**可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用）**，如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

**注意的是我们不能通过weak_ptr直接访问对象的方法**，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：
`shared_ptr p = pa->pb_.lock(); p->print();`

### 1.8怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码

**1、判断一个数是不是二的倍数，即判断该数二进制末位是不是0：**

```c++
a % 2 == 0 或者a & 0x0001 == 0。
```

**2、求一个数中1的位数，可以直接逐位除十取余判断：（要考虑吧负数)**

**3、求二进制中1的位数：**

- 常规解法：把1左移和该数挨个与
- 牛逼解法：把一个整数-1，再和原整数做与运算，会把该整数最右边的1变成0，那么一个整数的二进制里有多少个1就可以进行多少次这样的操作。

### 1.9请回答一下数组和指针的区别

![1565753378232](pic/1565753378232.png)

### 1.10请你回答一下野指针是什么？

野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。

### 1.11请你介绍一下C++中的智能指针

智能指针主要用于管理在堆上分配的内存，**它将普通的指针封装为一个栈对象**。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。

### 1.12请你回答一下智能指针有没有内存泄露的情况

当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。例如：

```c++
#include <memory>
#include <iostream>
using namespace std;
class Child;
class Parent{
private:
	shared_ptr<Child> childPtr;
public:
	void setChild(shared_ptr<Child> child){
		this->childPtr=child;
	}
	void doSomething(){
		if(this->childPtr.use_count()){
			
		}
	}
	~Parent(){
		cout<<"parent delete."<<endl;
	}
};
class Child{
private:
	shared_ptr<Parent> parentPtr;
public:
	void setParent(shared_ptr<Parent> parent){
		this->parentPtr=parent;
	}
	void doSomething(){
		if(this->parentPtr.use_count()){
			
		}
	}
	~Child(){
		cout<<"child delete."<<endl;
	}
};
int main(){
	weak_ptr<Parent> pp;
	weak_ptr<Child> cc; 
	{
		shared_ptr<Parent> p(new Parent);
		shared_ptr<Child> c(new Child);
		p->setChild(c);
		c->setParent(p);
		pp=p;
		cc=c;
		cout<<"Parent的引用指针个数："<<pp.use_count()<<endl; 
		cout<<"Child的引用指针个数："<<cc.use_count()<<endl; 
	}	//正常来说到这一步两个智能指针对象会被析构，引用计数-1结果为1！所以Parent和Child对象并没有被析构 
	cout<<"Parent的引用指针个数："<<pp.use_count()<<endl; 
	cout<<"Child的引用指针个数："<<cc.use_count()<<endl; 
} 
```

上述代码中，parent有一个shared_ptr类型的成员指向孩子，而child也有一个shared_ptr类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针c和p，随后将c和p分别又赋值给child的智能指针成员parent和parent的智能指针成员child。从而形成了一个循环引用

### 1.13请你来说一下智能指针的内存泄漏如何解决

为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，**其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。**

## 2.基本语言（2）

### 2.1请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

**C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。**因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

### 2.2请你来说一下函数指针

**1、定义**：函数指针是指向函数的指针变量。

函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。

C在编译时，**每一个函数都有一个入口地址**，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。

**2、用途：**调用函数和做函数的参数，比如回调函数。

**3、示例：**

```c++
char * fun(char * p)  {…}       	// 函数fun
char * (*pf)(char * p);             // 函数指针pf，参数和返回值要保持一致
pf = fun;                        // 函数指针pf指向函数fun
pf(p);                        	 // 通过函数指针pf调用函数fun
```

### 2.3 请你来说一下fork函数

Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：

```c++
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。

最常见的fork( )用法是创建一个新的进程，**然后使用exec( )载入二进制映像，替换当前进程的映像**。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，**例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。**

**fork之后父子进程的差异：**

- 父子相同处：（各自独有） 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式...
- 父子不同处： 1.进程ID   2.fork返回值   3.父进程ID    4.进程运行时间    5.闹钟(定时器)   6.未决信号集
  似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？
  当然不是!父子进程间遵循**读时共享写时复制**的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。   

### 2.4请你来说一下C++中析构函数的作用

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。

如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（==即使自定义了析构函数，编译器也总是会为我们合成一个析构函数==，并且**如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数**），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。

如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。（与构造相反）

### 2.5请你来说一下静态函数和虚函数的区别

静态函数在**编译**的时候就已经确定运行时机，虚函数在**运行**的时候动态绑定。**虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。**

### 2.6介绍一下编译和运行

一个典型的程序的运行步骤大概是这个样子：

​	1、操作系统创建进程后把控制权交给这个神秘的入口函数.
​	2、入口函数对运行库和程序运行环境进行初始化，包括堆分配，I/O资源的分配，线程，全局变量构造等。
​	3、入口函数调用main函数，执行程序主体。
​	4、main返回之后，回到入口函数，清理堆，关闭I/O,析构全局变量，然后结束进程。

**编译时：**就是编译器帮你把源代码翻译成机器能识别的代码，这个过程中做的啥类型检查也就叫编译时类型检查,或静态类型检查(所谓静态嘛就是没真把代码放内存中运行起来,而只是把代码当作文本来扫描下).所以有时一些人说编译时还分配内存啥的肯定是错误的说法.

**运行时：**所谓运行时就是代码跑起来了.被装载到内存中去了.(你的代码保存在磁盘上没装入内存之前是个死家伙.只有跑到内存中才变成活的).而运行时类型检查就与前面讲的编译时类型检查(或者静态类型检查)不一样.不是简单的扫描代码.而是在内存中做些操作,做些判断.

**编译（静态）初始化：**静态初始化指的是用常量来对变量进行初始化,主要包括 zero initialization 和 const initialization，静态初始化在程序加载的过程中完成，对简单类型(内建类型，POD等)来说，从具体实现上看，zero initialization 的变量会被保存在 bss 段（全局未初始化区），const initialization 的变量则放在 data 段（全局初始化区）内，程序加载即可完成初始化，这和 c 语言里的全局变量初始化基本是一致的。

**运行（动态）初始化：**动态初始化主要是指需要经过函数调用才能完成的初始化，比如说：`const int i = get_size()`，或者是复杂类型（类）的初始化（需要调用构造函数）等。这些变量的初始化会在 main 函数执行前由运行时调用相应的代码从而得以进行(函数内的 static 变量除外)。

### 2.7请你说一说重载和覆盖

重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中
重写：子类继承了父类，**父类中的函数是虚函数**，在子类中重新定义了这个虚函数，这种情况是重写

### 2.8请你说一说strcpy和strlen

**strcpy**是字符串拷贝函数，原型：

`char *strcpy(char* dest, const char *src);`

从src逐字节拷贝到dest，直到遇到'\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,**安全版本是strncpy函数。**
**strlen**函数是计算字符串长度的函数，返回从开始到'\0'之间的字符个数。

### 2.9请你说一说你理解的虚函数和多态

多态的实现主要分为静态多态和动态多态，**静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。**举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，**实际的虚函数在代码段(.text)中**。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

### 2.10请你来说一说++i和i++的实现

**++i:(可以做左值)**

```c++
int&  int::operator++（）
{
	*this +=1；
	return *this；
}
```

**i++:(不可以做左值)**

```c++
const int  int::operator（int）
{
	int oldValue = *this；
	++（*this）；
	return oldValue；
}
```

### 2.11说明C++中static,const以及static const成员变量的初始化

在C++中，static静态成员变量不能在类的内部直接初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，static关键字只能用于类定义内部的声明中，定义时不能标示为static。

在C++中，const的成员变量也不能在类定义出初始化，只能通过构造函数初始化列表进行，并且必须有构造函数，const数据成员只在某个对象生存期内是常量，而对整个类而言却是可变的。因为类可以创建多个对象，不同的对象没被创建时，编译器不知道cosnt数据成员的值是什么。如下例：

```c++
class Test{
public:
    Test():a(0){}
    enum{size=100,size2=200};
private:
    const int a;	//只能在构造函数初始化列表初始化
    static int b;	//只能在类的外边定义并初始化
    const static int c;	//与static const int相同，c为整形，所以可以在此处初始化，但仍要在类定义体外进行定义(先定义再初始化嘛)，注意c为非整形时，不能在此处初始化
};
int Test:b=0;	//static不能写
const int Test::c=0;
```

### 2.12如何用宏求结构体的内存偏移地址

### 2.17请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？

常量在C++里的定义就是一个top-level const加上对象类型，**常量定义必须初始化**。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。**对于字面值常量，常量存放在常量存储区。**

### 2.18请你来回答一下const修饰成员函数的目的是什么？

const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。

## 3.基本语言（3）

### 3.1如果同时定义了两个函数，一个带const，一个不带，会有问题吗？

不会，这相当于函数的重载。

### 3.2请你来说一说隐式类型转换

首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。
`A *aa=new B;	//若B不是public继承，则指针不能隐式转`	

### 3.3说说你了解的类型转换

**reinterpret_cast：**可以用于任意类型的指针之间的转换，**对转换的结果不做任何保证**，不安全
**dynamic_cast：**这种其实也是不被推荐使用的，更多使用static_cast，**dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常**
**const_cast：**对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。
**static_cast：**完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。用的最多最广泛

### 3.4请你来说一说C++函数栈空间的最大值

默认是1M，不过可以调整

### 3.5请你来说一说extern“C”

C++调用C函数需要extern C，因为C语言没有函数重载。是为了支持重载机制，在编译生成的汇编码中，要对函数的名字进行一些处理，加入比如函数的返回类型等信息。而在c语言中，只是简单的函数名字而已，不会加入其它的信息，也就是说:c++和c语言对产生的函数名字的处理是不一样的。

extern “C"告诉编译器该函数是用C编译器编译的，请用C的方式来链接他们，用法在声明函数时，前面加上这句话

### 3.6请你回答一下new/delete与malloc/free的区别是什么

1、malloc和free是C/C++语言的标准库函数，new和delete是C++的运算符
2、new自动计算需要分配的空间，而malloc需要手工计算字节数
3、new是类型安全的（编译时可以指出错误），而malloc不是
4、new调用operator new 分配足够的空间，并且调用相关对象的构造函数，而malloc不能调用构造函数；
5、malloc/free需要库文件支持，new/delete则不需要

### 3.7请你说说你了解的RTTI

RTTI， Run-Time Type Identification，称为 运行时类型识别 ，旨在为程序在运行阶段确定对象的类型提供一种标准方式。

运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针**。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info**

举例：
![1565918787578](pic/1565918787578.png)
typeid(*obj).name() 可以获得当前 obj 指针指向的实际的对象类型，用cout 可以将其打印出来，再通过 if 语句进行比对，比对完成后，就可以将obj 通过 dynamic_cast 的方式将其转化成为 bird 的指针 。

转化时要注意：dynamic_cast 后面跟两个尖括号，中间写上要转化的目标类型。

**关于 dynamic_cast 的注意事项：**

​	1、只能应用与指针和引用的转换，即只能转化为某一个类型的指针或某一个类型的引用，而不能是某类型本身
​	2、要转化的类型中必须包含虚函数，如果没有虚函数，转换就会失败
​	3、如果转换成功，返回子类的地址，如果转换失败，返回NULL

**关于 typeid 的注意事项：**

​	1、**typeid 返回一个 type_info 的对象引用**
​	2、如果想通过基类的指针指向派生类的数据类型，基类就必须要带有虚函数，否则，在使用typeid 时，就只能返回定义时所使用的数据类型
​	3、typeid 只能获取对象的实际类型，即便这个类含有虚函数，也只能判断当前对象是基类还是派生类，而不能判断当前指针是基类还是派生类

### 3.8请你说说虚函数表具体是怎样实现运行时多态的?

包含虚函数的类才会有虚函数表， 同属于一个类的对象**共享虚函数表**， 但是有各自的_vptr。虚函数表实质是一个指针数组，里面存的是虚函数的函数指针。

结构示意：有几个父类就会有几个虚函数表，子类会重写继承来的虚函数表。父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。
![1565919679613](pic/1565919679613.png)

子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。

### 3.9请你说说C语言是怎么进行函数调用的？

每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp（栈指针）指针压栈。

### 3.10请你说说C语言参数压栈顺序？

从右到左

### 3.11请你回答一下C++中拷贝赋值函数的形参能否进行值传递？

不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。

### 3.12请你说一说select

### 3.13 请你说说fork,wait,exec函数

父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，**exec函数可以加载一个elf文件去替换父进程**，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1

如果想通过基类的指针指向派生类的数据类型，基类就必须要带有虚函数，否则，在使用typeid 时，就只能返回定义时所使用的数据类型

3、typeid 只能获取对象的实际类型，即便这个类含有虚函数，也只能判断当前对象是基类还是派生类，而不能判断当前指针是基类还是派生类

## 4.容器和算法

### 4.1请你来说一下map和set有什么区别，分别又是怎么实现的？

map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。

map和set区别在于：

（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。

（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。**其原因是因为map和set是根据关键字排序来保证其有序性的**，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。

（3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，**mapped_type类型没有默认值也不应该使用**。如果find能解决需要，尽可能用find。

## 5.类和数据抽象

### 5.1请你来说一下C++中类成员的访问权限

C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员

### 5.2请你来说一下C++中struct和class的区别

在C++中，可以用struct和class定义类，都可以继承。区别在于：struct的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。

另外，class还可以定义模板类形参，比如template <class T, int i>。

### 5.3 请你回答一下C++类内可以定义引用数据成员吗？

可以，必须通过成员函数初始化列表初始化。

## 6.面向对象与泛型编程

### 6.1请你回答一下什么是右值引用，跟左值又有什么区别？

右值引用是C++11中引入的新特性 , 它实现了**转移语义和精确传递**。它的主要目的有两个方面：

\1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。

\2. 能够更简洁明确地定义泛型函数。

**左值和右值的概念**：

左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。

右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。

**右值引用和左值引用的区别：**

\1. 左值可以寻址，而右值不可以。

\2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。

\3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。

## 7.编译与底层



# 操作系统

## 1.操作系统（1）

### 1.1请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的。

**基本概念：**

进程：是对运行时程序的封装，是系统进行**资源调度和分配的的基本单位**，实现了**操作系统的并发；**

线程：是进程的子任务，**是CPU调度和分派的基本单位**，用于保证程序的实时性，实现**进程内部的并发**；线程是操作系统**可识别的最小执行和调度单位**。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），共享打开的文件队列和其他内核资源。

**区别：**

1.一个线程只能属于一个进程，而一个进程可以有多个线程，但**至少有一个线程**。线程依赖于进程而存在。

2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）

3.**进程是资源分配的最小单位，线程是CPU调度的最小单位；**

4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，**在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置**。而线程切换只须保存和设置**少量寄存器**的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。

5.通信：由于同一进程中的**多个线程具有相同的地址空间**，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，需要进程同步和互斥手段的辅助，以保证数据的一致性。线程间可以直接读写进程数据段（如全局变量）来进行通信。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预

6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。

7.**进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉**

8.进程适应于多核、多机分布；线程适用于多核。

#### **进程间通信的方式：**

进程间通信主要包括**管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。**

- **1.管道：**

管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信

​		1.1 普通管道PIPE：
​		1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端
​		2)它只能用于**具有亲缘关系**的进程之间的通信（也是父子进程或者兄弟进程之间）
​		3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

​		1.2 命名管道**FIFO**：
​		1)FIFO可以在**无关的进程之间**交换数据
​		2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

- **2.系统IPC（Interprosses communication）**：

  **2.1 消息队列**

  消息队列，**是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记**。 (消息队列克服了信号传递信息少，**管道只能承载无格式字节流以及缓冲区大小受限**等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

  特点：
  1)消息队列是**面向记录**的，其中的消息具有特定的格式以及特定的优先级。
  2)消息队列**独立**于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
  3)消息队列**可以实现消息的随机查询**,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

​		**2.2 信号量semaphore**

​		信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个**计数器**，可以用来控制多个进程对共享资源的访问。**信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。**

​		特点：
​		1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。		
​		2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。		
​		3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。		
​		4)支持信号量组。

注：pv操作：就是来解决互斥与同步的问题的。

P操作：
	1.信号量有效（值>0）
	2.信号量值减1
	3.任务继续运行
	4.信号量值=0
	5.等待信号量的进程被列入等待信号量进程列表。
V操作：
	1.没有进程等待信号量
	2.信号量的值加1
	3.有进程等待信号量
	4.信号量的值加1
	5.等待的其中一个进程进入就绪状态

​	**2.3 信号signal**

​	信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

​	**2.4 共享内存（Shared Memory）**

​		它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等

​		特点：
​			1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取
​			2)因为多个进程可以同时操作，所以需要进行同步
​			3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

- **3.套接字SOCKET：**

socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。

#### 线程间通信的方式:

**临界区：**通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；

**互斥量Synchronized/Lock：**采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

**信号量Semphare：**为控制具有有限数量的用户资源而设计的，**它允许多个线程在同一时刻去访问同一个资源**，但一般需要限制同一时刻访问此资源的最大线程数目。

**事件(信号)，Wait/Notify**：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

### 1.2请你说一说Linux虚拟地址空间

**为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。**

虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。**所有进程共享同一物理内存**，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做**存储器映射**），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。

# 计算机网络

# 数据库

# 算法和数据结构

### 1.链表

**首先，关于单链表中的环，一般涉及到一下问题：**

#### 1.给一个单链表，判断其中是否有环的存在；

​	对于这个问题我们可以采用“快慢指针”的方法。就是有两个指针fast和slow，开始的时候两个指针都指向链表头head，然后在每一步操作中slow向前走一步即：slow = slow->next，而fast每一步向前两步即：
fast = fast->next->next。由于fast要比slow移动的快，如果有环，fast一定会先进入环，而slow后进入环。当两个指针都进入环之后，经过一定步的操作之后二者一定能够在环上相遇，并且此时slow还没有绕环一圈，也就是说一定是在slow走完第一圈之前相遇。

```c++
typedef struct node{  
    char data ;  
    node * next ;  
}Node;  
bool exitLoop(Node *head)  
{  
    Node *fast, *slow ;  
    slow = fast = head ;  
  
    while (slow != NULL && fast -> next != NULL)  
    {  
        slow = slow -> next ;  
        fast = fast -> next -> next ;  
        if (slow == fast)  
            return true ;  
    }  
    return false ;  
} 
```

#### 2.如果存在环，找出环的入口点；

在问题一中两指针相遇后，让一个指针从头结点开始，另一个从相遇结点开始，并以相同速度向后指，再次相遇时就是环的入口结点。

证明：https://blog.csdn.net/liushall/article/details/80444753

```c++
Node* findLoopStart(Node *head)  
{  
    Node *fast, *slow ;  
    slow = fast = head ;  
  
    while (slow != NULL && fast -> next != NULL)  
    {  
        slow = slow -> next ;  
        fast = fast -> next -> next ;  
        if (slow == fast) break ;  
    }  
    if (slow == NULL || fast -> next == NULL) return NULL ; //没有环，返回NULL值  
  
    Node * ptr1 = head ; //链表开始点  
    Node * ptr2 = slow ; //相遇点  
    while (ptr1 != ptr2)   
    {  
        ptr1 = ptr1 -> next ;  
        ptr2 = ptr2 -> next ;  
    }  
    return ptr1 ; //找到入口点  
} 
```



#### 3.如果存在环，求出环上节点的个数；

思路1：记录下相遇节点存入临时变量tempPtr，然后让slow(或者fast，都一样)继续向前走slow = slow -> next；一直到slow == tempPtr; 此时经过的步数就是环上节点的个数；

思路2： 从相遇点开始slow和fast继续按照原来的方式向前走slow = slow -> next; fast = fast -> next -> next；直到二者再次项目，此时经过的步数就是环上节点的个数 。

#### 4.如果存在环，求出链表的长度；

到这里，问题已经简单的多了，因为我们在问题1、2、3中已经做得足够的”准备工作“。

我们可以这样求出整个链表的长度：

**链表长度L = 起点到入口点的距离 + 环的长度r;**

已经知道了起点和入口点的位置，那么两者之间的距离很好求了吧！环的长度也已经知道了，因此该问题也就迎刃而解了！

#### 5.如果存在环，求出环上距离任意一个节点最远的点（对面节点）；

思路1：快慢指针，让快指针=起始点，慢指针此时的位置就是

思路2：取环的一半，开始走一半的长度

#### 6.（扩展）如何判断两个无环链表是否相交；

对于问题6（扩展）如何判断两个无环链表是否相交，和7（扩展）如果相交，求出第一个相交的节点，其实就是做一个问题的转化：

假设有连个链表listA和listB，如果两个链表都无环，并且有交点，那么我们可以让其中一个链表（不妨设是listA）的为节点连接到其头部，这样在listB中就一定会出现一个环。

因此我们将问题6和7分别转化成了问题1和2.

#### 7.（扩展）如果相交，求出第一个相交的节点；



# 项目相关

# 设计模式



