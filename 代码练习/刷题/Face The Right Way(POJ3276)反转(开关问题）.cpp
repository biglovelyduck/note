/*反转（开关问题）
Face The Right Way （POJ No. 3276）
N 头牛排成了一列。每头牛或者向前或者向后。为了让所有的牛都面向前方，农夫约翰买了
一台自动转向的机器。这个机器在购买时就必须设定一个数值K，机器每操作一次恰好使K
头连续的牛转向。请求出为了让所有的牛都能面向前方需要的最少的操作次数M 和对应的
最小的K。
限制条件
. 1≤N≤5000*/

/*首先我们来看看对于一个特定的K如何求出让所有的牛面朝前方的最小操作次数。如果把牛的方
向作为状态进行搜索的话，由于状态数有2N个，是无法在时限内找出答案的。那么不搜索的话要
怎么办呢？
首先，交换区间反转的顺序对结果是没有影响的。此外，可以知道对同一个区间进行两次以上
的反转是多余的。由此，问题就转化成了求需要被反转的区间的集合。于是我们先考虑一下最
左端的牛。包含这头牛的区间只有一个，因此如果这头牛面朝前方，我们就能知道这个区间不
需要反转。
反之，如果这头牛面朝后方，对应的区间就必须进行反转了。而且在此之后这个最左的区间就再
也不需要考虑了。这样一来，通过首先考虑最左端的牛，问题的规模就缩小了1。不断地重复下
去，就可以无需搜索求出最少所需的反转次数了。
此外，通过上面的分析可以知道，忽略掉对同一个区间重复反转这类多余操作之后，只要存在让
所有的牛都朝前的方法，那么操作就和顺序无关可以唯一确定了。
这个算法的复杂度又如何呢？首先我们需要对所有的K都求解一次，对于每个K我们都要从最左
端开始来考虑N头牛的情况。此时最坏情况下需要进行N.K+1次的反转操作，而每次操作又要反
转K头牛，于是总的复杂度就是O(N3)。这样的话还不足以在时限内解决问题。但是区间反转的部
分还是很容易进行优化的。
f[i] := 区间[i, i+K.1]进行了反转的话则为1，否则为0
这样，在考虑第i头牛时，如果1
 为奇数的话，则这头牛的方向与起始方向是相反的，
否则方向不变。由于
所以这个和每一次都可以用常数时间计算出来，复杂度就降为了O(N2)，能在时限内解决了。*/

//输入
int N;//N头牛
int dir[MAX_N];//牛的方向：（0：F,1：B）

int f[MAX_N];//f[i]：区间[i,i+K+1]是否进行了反转 ，是为1 

//固定K，求对应的最小操作数
//无解的话返回-1
int calc(int K){
	memset(f,0,sizeof(f));
	int res=0;
	int sum=0;//f的和 
	for(int i=0;i+K<=N;i++){
		
	}
} 
 
