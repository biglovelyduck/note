//监狱里有P 个并排着的牢房。从左至右依次编号为1, 2, …, P。
//最初所有的牢房里都住着一个囚犯。相邻的两个牢房之间有一个窗户，
//可以通过它与相邻牢房里的囚犯对话。
/*现在要释放一些囚犯。如果释放某个牢房里的囚犯，其相邻的牢房里的囚犯就会知道，因而
发怒暴动。所以，释放某个牢房里的囚犯同时，必须要贿赂两旁相邻牢房里的囚犯一枚金币。
另外，为了防止释放的消息在相邻牢房间传开，不仅两旁直接相邻的牢房，所有可能听到消
息的囚犯，即直到空牢房为止或直到监狱两端为止,此间的所有囚犯都必须给一枚金币。
现在要释放a1, a2, …, aQ 号牢房里的Q 名囚犯，释放的顺序还没确定。如果选择所需金币数
量尽量少的顺序释放，最少需要多少枚金币？

限制条件Large：
1<=P<=10000
1<=Q<=100 

输入
P = 20, Q = 3, A = {3, 6, 14}
输出
35(按照牢房14、牢房6、牢房3的顺序释放，则需要19 + 12 + 4即35枚金币，是最少的)
*/

//输入
int P,Q,A[MAX_Q+2];//A中保存取出囚犯的牢房数据，囚犯从下标1开始编号 
//dp[i][j]:将从A[i]号囚犯到A[j]号囚犯的连续部分里的所有囚犯都释放时，所需的最少金币数
//把左端当做0号囚犯，右端当做Q+1号囚犯，这样dp[0][Q+1]就是答案 
int dp[MAX_Q+1][MAX_Q+2];
void solve(){
	//将两端加入A中
	A[0]=0;
	A[Q+1]=P+1;
	//初始化
	for(int q=0;q<=Q;q++){
		dp[q][q+1]=0;	
	}
	//从短的区间开始填充dp
	for(int w=2;w<=Q+1;w++){
		for(int i=0;i+w<=Q+1uu;i++){
			//计算dp[i][j]
			int j=i+w,t=INT_MAX 
			// 枚举最初释放的囚犯，计算最小的费用
			for (int k = i + 1; k < j; k++) {
				t = min(t, dp[i][k] + dp[k][j]);
			}
			// 最初的释放还需要与所释放囚犯无关的A[j]-A[i]-2枚金币
			dp[i][j] = t + A[j] - A[i] - 2;
		}
	} 
	cout<<dp[0][Q+1];
}
