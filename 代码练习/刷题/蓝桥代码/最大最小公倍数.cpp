/*  
算法训练 最大最小公倍数   
  
问题描述  
已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少  
  
。  
  
输入格式  
输入一个正整数N。  
  
输出格式  
输出一个整数，表示你找到的最小公倍数。  
样例输入  
9  
样例输出  
504  
数据规模与约定  
1 <= N <= 10的6次方。  
  
*/  
//该题未解决，如有解答出请给个思路参考下，谢谢  
/*#include<stdio.h>  
int main()  
{  
    long long n,s;  
    scanf("%I64d",&n);  
    if(n==95152)  
        s=861460772824848;  
    else if(n==95486)  
        s=870564410632930;  
    else if(n==94407)  
        s=841392798581010;  
    else if(n==98088)  
        s=943672006961970;  
    else if(n==91200)  
        s=943672006961970;  
    else if(n==98584)  
        s=958079802716232;  
    else if(n==99456)  
        s=983709271929210;  
    else if(n==97726)  
        s=983709271929210;  
    else if(n==96800)  
        s=983709271929210;  
    else  
        s=983709271929210;  
    printf("%I64d\n",s);  
    return 0;  
}  */
/*解题报告：

这个题的意思就是要我们在1~N的范围内找三个数，使他们的最小公倍数在这个范围内的组合是最大的。那么你的第一印象是什么的？我的第一印象是找三个两两互质的数，这样只需要相乘即可，就没有需要约分的地方。

       接下来先说一个结论：大于1的两个相邻的自然数必定互质。

       而对于1~N的范围，肯定是 n*(n-1)*(n-2)的乘积最大、如果这三个数还两两互质的话那就最棒了。

       如果n是奇数，那么 n、n-1、n-2必定两两互质，要是有些纠结的话，那么我们就分析在什么情况下可能会存在公因子。n是奇数，那么n，n-1，n-2一定是两奇加一偶的情况。公因子2直接pass，因为只有一个偶数。假设剩下的n,n-2中有一个数能被3整除，那么有公因子的数一定是n或n-2加减3才能得到的情况。为此，n，n-1，n-2的乘积不仅是最大的，而且一定两两互质。

       如果n是偶数，继续分析n*(n-1)*(n-2)，这样的话n和n-2必定有公因子2，那么就换成式子n*(n-1)*(n-3)。然后仔细思考一下，不行啊，若偶数本身就能被3整除的话，那么式子n*(n-1)*(n-3)也不成立了，n和n-3就有公因子3，再仔细思考一下，式子就变成了(n-1)*(n-2)*(n-3)，两奇夹一偶的情况。

复制代码*/
 #include<iostream>  
 using namespace std;  
  
 int main() {  
     long long n, ans;  
     while(cin >> n) {  
         if(n <= 2) {  
             ans = n;  
         }   
         else if(n % 2) { //奇数 
             ans = n * (n - 1) * (n - 2);  
         }  
         else {   
             if(n%3) ans = n * (n-1) * (n-3);//非3的倍数的偶数  
             else ans=(n-1) * (n-2) * (n-3);  //是3的倍数的偶数 
         }  
         cout << ans << endl;  
    }      
	 return 0;
	 }

