/*Jessica’s Reading Problem （POJ No.3320）
为了准备考试，Jessica 开始读一本很厚的课本。要想通过考试，必须把课本中所有的知识点
都掌握。这本书总共有P 页，第i 页恰好有一个知识点ai（每个知识点都有一个整数编号）。
全书中同一个知识点可能会被多次提到，所以她希望通过阅读其中连续的一些页把所有的知
识点都覆盖到。给定每页写到的知识点，请求出要阅读的最少页数。
限制条件
. 1 ≤ P ≤ 106*/ 
/*我们假设从某一页s开始阅读，为了覆盖所有的知识点需要阅读到t。这样的话可以知道如果从s+1
开始阅读的话，那么必须阅读到t'≥t页为止。由此这题也可以使用尺取法。
在某个区间[s,t]已经覆盖了所有的知识点的情况下，下一个区间[s+1,t'](t'≥t)要如何求出呢？
所有的知识点都被覆盖.每个知识点出现的次数都不小于1
由以上的等价关系，我们可以用二叉树等数据结构来存储[s,t]区间上每个知识点的出现次数，这
样把最开头的页s去除后便可以判断[s+1,t]是否满足条件。
从区间的最开头把s取出之后，页s上书写的知识点的出现次数就要减一，如果此时这个知识点的
出现次数为0了，在同一个知识点再次出现前，不停将区间末尾t向后推进即可。每次在区间末尾
追加页t时将页t上的知识点的出现次数加1，这样就完成了下一个区间上各个知识点出现次数的更
新，通过重复这一操作可以以O(PlogP)的复杂度求出最小的区间。*/

int P;//页数 
int a[MAX_P];//每页的知识点编号
void solve(){
	//计算全部知识点的总数
	set<int> all;
	for(int i=0;i<P;i++){
		all.insert(a[i]);//去重 
	} 
	int n=all.size();//知识点的种类数 
	//尺取法求解
	int s=0,t=0,num=0;
	map<int,int> count;//知识点->出现的次数的映射
	int res=P;
	for(;;){
		while(t<P&&num<n){
			if(count[a[t++]]++==0){
				//出现新的知识点
				num++; //知识点种类的数量 
			}
		}
		if(num<n) break;
		res=min(res,t-s);
		if(--count[a[s++]]==0){
			//某个知识点出现次数为0了
			num--; 
		} 
	}
	cout<<res; 
} 
