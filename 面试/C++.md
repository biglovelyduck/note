# 一、变量

## 1.全局变量和static变量

​		全局变量（外部变量）再冠以satatic就成了静态的全局变量。全局变量本身就是静态存储方式，存放在静态存储区（全局存储区），静态全局变量当然也是静态存储方式，存储方式并无异同。区别在于非静态全局变量作用域是整个源程序，当一个源程序有多个源文件组成时，非静态全局变量在各个源文件中都是有效的。而静态全局变量限制了其作用域只在该源文件内，同一个源程序的其他源文件不能使用他。
​		static全局变量和普通的全局变量的区别在于static全局变量只能初始化一次，防止在其他文件单元被引用。
​		局部变量存放在栈区，只有在函数或者代码块中存在，静态局部变量则改变了他的存储方式，也即改变了生存期。

PS：
		静态存储：是指在程序运行期间分配固定的存储空间的方式，在变量定义时就分定存储单元并一直保持不变，直至整个程序结束。
		动态存储：是在程序执行过程中，使用它时才分配存储单元，使用完毕立即释放，典型例子是形参。

## 2.static函数和普通函数

​		static函数与普通函数的作用域不同，static函数仅在本文件中，只有在源文件中使用的函数应该声明为static的，内部（static函数）应该在当前源文件中说明和定义。普通函数可以在别的文件中使用，默认是extern的，使用的时候需要用头文件说明。

​		static函数在内存中只有一份，普通函数在每个被调用中（栈）维持一份拷贝。函数存放在代码段（正文段）中，每个函数都有它的地址，函数名和函数地址会有映射，映射存在符号表中，这些地址都是偏移地址，在编译期间就确定。		

## 3.全局数组，静态数组，局部数组初始化

静态全局数组和全局数组定义后，虽未初始化，但编译器默认用数值0填充，也就是初始化；
静态局部数组定义后，未初始化，结果也是自动填充0，也就是初始化；
局部数组就不一样，定义后不初始化，数组各元素值将用随机数值填充。但是如果初始化了最开始的几个数组元素，那么剩下的所有元素编译器将初始化为0。

## 4.指针和引用

本质：指针是地址，通过地址找到所需的变量单元，引用是别名

具体：指针可以在运行时改变其指向的值，引用和某个对象绑定后就不可以更改
			内存：指针会分配内存，引用不会（只是别名）
			在参数传递时，引用会做类型检查（安全），而指针不会（不安全）
			引用不能为空，指针可以为空
			指针可以有多级，引用只能有一级

## 5.强制类型转换

**static_cast**:完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。用的最多最广泛。只要不包含底层const，都可以使用。适合将较大算术类型转换成较小算术类型。

**reinterpret_cast**:可以用于任意类型的指针之间的转换，**对转换的结果不做任何保证**，不安全。通常为算术对象的位模式提供较低层次上的重新解释。如将int\*转换成char*。很危险！

**dynamic_cast**：这种其实也是不被推荐使用的，更多使用static_cast，一种动态类型识别。转换的目标类型，即type，是指针或者左右值引用，主要用于基类指针转换成派生类类型的指针(或引用)，通常需要知道转换源和转换目标的类型。如果转换失败，返回0（转换目标类型为指针类型时）或抛出bad_cast异常（转换目标类型为引用类型时）

**const_cast**：只能改变底层const，例如指向const的指针(指向的对象不一定是常量，但是无法通过指针修改)，如果指向的对象是常量，则这种转换在修改对象时，结果未定义。PS：const成员函数不能调用普通成员函数
另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。

## 6.修改const变量，const和volatile关键字

首先，c和c++的const是不同的。在c语言中用const修饰的变量还是一个变量，限定一个变量是可读的，必须在声明的时候初始化，const变量可以通过指针修改；

而在C++中用const修饰过后的变量，就变成常量了。声明可以不用初始化，因为const修饰后就变成常量了。不可以通过指针修改，但是可以用关键字volatile修改。

**不建议修改const变量的值，即使修改也要熟悉当前使用的编译器对于该 未定义行为 是如何解释的**。

**常量折叠**：指const变量（即常量）值**放在编译器的符号表中**，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化。而在此基础上加上volatile修改符，即告诉编译器该变量属于易变的，不要对此句进行优化，每次计算时要去内存中取数取数，而不是从上次读到的数据。volatile可以保证对特殊地址的稳定访问。

## 7.静态类型获取和动态类型获取

typeid、dynamic_cast:转换目标类型必须是引用类型

由于继承导致对象的指针和引用具有两种不同的类型： **静态类型** 和 **动态类型** 。

静态类型：由指针和引用声明时的类型，编译时就知道变量的类型

动态类型：由他实际指向的类型确定，运行时才知道变量的类型

**不允许隐式转换的是强类型，允许隐式转换的是弱类型**

#### 如何获取呢？

通过RTTI（运行时类型识别），能够通过基类的指针或引用来检索其所指对象的实际类型。c++通过下面两个操作符提供RTTI。

（1）typeid：返回指针或引用所指对象的实际类型。如果操作数不是类类型或者是没有虚函数的类，则获取其静态类型；如果操作数是定义了虚函数的类类型，则计算运行时类型。

（2）dynamic_cast：将基类类型的指针或引用安全的转换为派生类型的指针或引用。

对于带虚函数的类，在运行时执行RTTI操作符，返回动态类型信息；对于其他类型，在编译时执行RTTI，返回静态类型信息。

typeid操作符的返回类型就是typeinfo，因为typeinfo提供了各种操作符，所以可以用==判断，type_info的默认构造函数、拷贝构造函数、赋值操作符都定义为private，创建type_info对象的唯一方法就是使用typeid操作符。

详见：https://www.cnblogs.com/zhuyf87/archive/2013/03/15/2960899.html

## 8.如何比较浮点数数大小

为什么不能用等号？

1.浮点精度不同	2.寄存器和内存表示浮点数精度不同	3.内存中精度的误差

对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！

```c
if( fabs(f1-f2) < 预先指定的精度）		//fabs浮点数的绝对值，abs针对整数
{
      ...
}
```

# 二、函数

## 1.重载覆盖隐藏

重载（参数必须不同（const修饰形参）、重载和作用域、继承中的重载（using）、重载和const成员函数）

**重载**：同一个类内，函数名相同，参数不同；

**覆盖**：即实现多态，基类中函数是virtual，子类中同名同参数；

**隐藏**：

1. 基类中函数virtual，子类中有**同名但不同参数**的函数，则所有基类同名函数被隐藏；

2. 基类中函数非virtual，子类中存在同名函数（参数可以相同或不同），所有基类同名函数被隐藏；

**隐藏时可以利用using base::fun;来调用基类函数，但被子类中同名同参数的函数只能调用子类的**

底层const重载：
		1）底层const即不能改变所指对象，所以传入常量和非常量都没有问题。
   故如果传入非常量或者指向非常量的指针，重载的函数都能调用，但是对于编译器优先选择非const版本
   传入常量或指向常量的指针时，只能选择const版本
  	 2）如果没有重载非const版本，但是当传入一个非常量实参时希望返回一个非常量引用，则需对调用
      结果进行const_cast转换。const_cast能转换底层const，但是如果传入的实参是一个常量，
      转换后修改的话结果未定义。同时这种方式也会加重调用者的负担

重载和作用域：函数里有同名的函数，外部重载的函数会被隐藏。

继承中的重载（隐藏）：父类的函数会被子类重载隐藏。

# 三、类

## 1.面向对象的三大特性（封装、继承、多态）

**封装：**是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。
**好处**：1、良好的封装能够减少耦合。2、类内部的结构可以自由修改。3、可以对成员进行更精确的控制。4、隐藏信息，实现细节。

**继承：**继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。

**多态：**前提有继承，虚函数子类实现，向上转型

## 2.struct和class的区别

1.默认继承权限：struct公有继承，class私有继承

2.默认访问权限：class私有，struct公有

3.大括号初始化：c语言的struct可以直接用大括号初始化，在C++中对struct的功能进行了扩展，struct可以被继承，可以包含成员函数，也可以实现多态，当用大括号对其进行初始化需要注意：
1）当struct和class中都定义了构造函数，就不能使用大括号对其进行初始化。
2）若没有定义构造函数，struct可以使用{ }进行初始化，而只有当class的所有数据成员及函数为public时，可以使用{ }进行初始化。
3）所以struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体

4.模板：class可以做类型模板

## 3.访问权限说明符

目的：加强类的封装性

1. **类的成员的访问控制说明符**用于控制**类的使用者**对类中成员的访问权限
2. **派生列表中的访问控制说明符**用于控制**派生类的使用者**对**派生类从基类继承的成员**的访问权限

![1567129880953](pic/1567129880953.png)

## 4.类的静态成员

（所属？静态成员函数不能声明成const、类类型的成员、定义时不能重复使用static、具有类内初始值的静态成员定义时不可再设初值）

**1.所属**：静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。静态成员的定义或声明要加个关键static。静态成员可以通过双冒号来使用即<类名>::<静态成员名>

**2.不可以调用非静态成员**：因为静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员必须在类实例化对象后才有内存空间，所以这个调用就出错了，就好比没有声明一个变量却提前使用它一样。

**3.类的静态成员变量在使用前必须先初始化（必须先定义比较准确）。**

**4.静态成员函数不能声明成const：**因为成员函数的 const 修饰的是 this 指针，而静态成员函数没有 this 指针。

**5.具有类内初始值的静态成员定义时不可再设初值，static的成员变量一定要在类外初始化，因为静态成员属于整个类，不可能在每个对象都初始化一遍。**

**6.能在类内初始化的只有一种，就是静态常量成员！**

## 5.构造函数

### 1.有哪些构造函数（默认、委托、拷贝、移动）

**默认：**创建一个类自己没有写任何构造函数，系统会默认生成一个无参构造函数，函数为空，什么也不做。**默认构造函数会在==需要的==时候自动生成（被编译器），自己定义的参数为空的构造函数也是默认构造函数！一个类只有一个默认构造函数。**

所以：**任何class如果没有定义default constructor（也就是不带参数的那个啦），编译器就会自动帮你合成一个**，**这句话是错的！！！**

- **平凡的无关紧要的构造函数（trival）**：用户并没有显示地定义默认构造函数，编译器会为它自动生成一个无关紧要（trivial）的默认构造函数，生成的默认构造函数什么也不错，既不会讲其成员变量置零，也不会做其他的任何事情，只是为了保证程序能够正确运行而已，这就是所谓的“需要”，如果还需要给初始化成员变量，这件事情还是交给程序员做吧！

- **不平凡的构造函数（non-trival)**

  - **1.含有包含默认构造函数的成员类对象**：如果该类包含一个成员类对象，<u>它有默认的构造函数</u>，那么这个类的隐式构造函数是<u>非平凡的</u>，并且<u>编译器需要为包含的这个成员类对象生成一个默认构造函数</u>。然后，这个编译器生成的默认构造函数只有在实际上被调用时才会被真正的生成。

  - **2.基类包含默认构造函数的基类：**类似的，要是一个继承的基类包含默认构造函数而该类本身没有默认的构造函数，那么编译器会生成一个默认构造函数，目的是初始化它的基类。

    当程序员为该类定义了多个构造函数，就是没定义默认构造函数呢？

    在这种情况下，编译器会在每一个构造函数中增加（augment）有关调用基类的默认构造函数部分代码。

  - **3.含有虚函数：**生成的默认构造函数是必须的当另外两个额外条件（满足其一）才是不平凡的：

      1.该类定义了（或继承了）虚函数。

      2.在该类的继承关系中，有一个或更多的虚基类。

    在编译时，在默认构造函数中会发生下面的两个类扩充（augmentation）：

      1.虚表会被产生，其内容被这个类的活动（active）虚函数填充。

      2.编译器为每个类对象生成一个虚指针（vtbl）。

  - **4.带有虚基类的类**：编译器会为该类添加一个类似虚指针的东西——“_vbcX”

**委托（c++11）：**一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说他把自己的一些（或全部）职责委托给了其他构造函数。使用方法类似调用基类的构造函数。

**拷贝：**拷贝构造函数是一种特殊的构造函数，其形参为本类对象的引用。
			作用：用一个已经存在的对象去初始化同类型的新对象。

**移动（c++11）：**拷贝构造函数时拷贝一个对象，而移动构造函数是直接直接把该对象的内存赋值给另一个对象初始化。<u>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。</u>

使用方法：类 `T` 的移动构造函数是非模板[构造函数](https://zh.cppreference.com/w/cpp/language/initializer_list)，其首个形参是 T&&、const T&&、volatile T&& 或 const volatile T&&，且无其他形参，或剩余形参均有默认值。调用移动构造函数，情况包括

- 初始化：`T a = std::move(b);` 或 `T a(std::move(b));`，其中 b 类型为 `T` ；

- 函数实参传递：`f(std::move(a));`，其中 `a` 类型为 `T` 而 `f` 为 Ret f(T t) ；

- 函数返回：在如 T f() 的函数中的 return a;，其中 `a` 类型为 `T`，它有移动构造函数。

  move函数作用：将左值转换成右值

**构造函数和赋值运算符的区别：**口诀，构造函数与赋值运算符的区别是，构造函数在创建或初始化对象的时候调用，而赋值运算符在更新一个对象的值时调用。

### 2.合成的默认构造函数

（默认行为？什么情况下不会合成？怎么解决？**如果成员包含类内初始值，合成默认构造函数会使用该成员的类内初始值初始化该成员**）

**对于C++默认构造函数，我曾经有两点==误解==：**

- **类如果没有定义任何的构造函数，那么编译器（一定会!）将为类定义一个合成的默认构造函数。**
- **合成默认构造函数会初始化类中所有的数据成员。**

**总结：**

1. 　　**合成默认构造函数总是不会初始化类的内置类型及复合类型的数据成员。**
2.   　**分清楚默认构造函数被程序需要与被编译器需要，只有被编译器需要的默认构造函数，编译器才会合成它。**

正文：

**默认行为**：什么都不做，只是为了让程序正确执行，不会初始化

**什么情况下不会合成：**类内只含有复合类型和内置类型的时候

**怎么解决：**四种情况见上一题，被需要会合成

### 3.拷贝构造函数

并不是所有未定义有拷贝构造函数的类编译器都会为其合成拷贝构造函数，编译器只有在必要的时候才会为其合成拷贝构造函数。

（调用时机、合成版的行为、explict？、为何参数必须是引用类型）

**调用时机**：4种（A a1=a2，A a1(a2)，传参，返回值）

**合成版的行为：**默认浅拷贝，合成复制构造函数会对成员逐个进行初始化，将新对象初始化为原对象的副本。
						   合成时机：有需要的时候被合成

**explicit**：explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。

**参数必须是引用类型**：不用引用参数值传递的时候就会无限递归地调用拷贝构造函数。

### 4.移动构造函数

（非拷贝而是窃取资源、与noexcept?、何时合成）

```c++
Test(Test&& t)noexcept;
Test& operator=(Test&& t)noexcept;		//参数为右值
```

**noexcept**：为了避免潜在的问题，除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，他就必须使用拷贝构造函数而不是移动构造函数，我们在进行自定义类型的对象移动而不是拷贝的时候，必须显示的告诉标准库我们的移动构造函数可以被安全的使用,将移动构造函数标记位noexcept来做到这一点。

在使用vector时建议配上noexcept全共同使用。

**何时合成**：当我们定义了自己的拷贝操作和析构函数时，编译器是不会帮我们合成默认移动构造函数的。

C++的默认析构函数不会释放指针所指的资源。
所以默认移动构造函数配合默认析构函数不会产生新对象资源没了的问题。

## 6.初始值列表

（顺序、效率(内置类型不进行隐式初始化故无所谓,但..)、无默认构造函数的成员,const成员,引用成员必须通过初始值列表初始化）

**顺序**：不是按照列表的顺序，而是按照内存模型中变量（声明时的定义）的顺序进行的，从而避免出现依赖。

**效率**：初始化列表效率>=在函数体里赋值。因为自定义类型在构造函数里面初始化会调用构造函数和拷贝运算符。

构造函数中，**成员变量一定要通过初始化列表来初始化的是**：
	1、const常量成员，因为常量只能在初始化，不能赋值，所以必须放在初始化列表中；
	2、引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表中；
	3、没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，**而是直接调用拷贝构造函数。**

## 7.赋值运算符相关

### 1.拷贝赋值运算符

（合成版的行为？、与delete？、自定义时**要注意自赋值**，参数与返回类型、大部分组合了拷贝构造函数与析构函数的工作）

**合成版的行为**：对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。

**delete**：C++11 中，可在想要 “禁止使用” 的特殊成员函数声明后加 “= delete”，就会禁止使用拷贝赋值运算符或者拷贝构造函数。

```c++
class Uncopyable  
{  
    Uncopyable(const Uncopyable &) =delete; // 阻止copying  
    Uncopyable &operator=(const Uncopyable &)=delete;  
};  
```

**参数const**：
		①我们不希望在这个函数中对用来进行赋值的“原版”做任何修改。
		②加上const，对于const的和非const的实参，函数就能接受；如果不加，就只能接受非const的实参。

**参数用引用**：这样可以避免在函数调用时对实参的一次拷贝，提高了效率。

**返回值：**一般地，返回值是被赋值者的引用，即*this
			①这样在函数返回时避免一次拷贝，提高了效率。		
			②更重要的，这样可以**实现连续赋值**，即类似a=b=c这样。如果不是返回引用而是返回值类型，那么，执行a=b时，调用赋值运算符重载函数，在函数返回时，由于返回的是值类型，所以要对return后边的“东西”进行一次拷贝，得到一个未命名的副本（有些资料上称之为“匿名对象”），然后将这个副本返回，而这个副本是右值，所以，执行a=b后，得到的是一个右值，再执行=c就会出错。

**提供默认拷贝赋值运算符的时机：**所谓默认，就是“以本类或本类的引用为参数”的意思，显示提供了就不会有默认

当用一个非类A的值（如int型值）为类A的对象赋值时

​		①如果匹配的构造函数和赋值运算符重载函数同时存在，会调用赋值运算符重载函数。

​		②如果只有匹配的构造函数存在，就会调用这个构造函数。

**不能友元**：编译器也要提供一个，二义性

**不能被继承**

### 2.阻止拷贝

（某些对象应该独一无二(比方说人)、C++11前:private并且不定义(试图拷贝会报链接错误)，C++11:=delete ）

《Effective C++:条款6》：若不想使用编译器自动生成的函数，就该明确拒绝

### 3.移动赋值运算符

（与noexcept？何时合成）

如果一个类定义了自己的拷贝构造函数，拷贝赋值运算符或析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。

当一个类没有定义任何自己版本的拷贝构造函数，拷贝赋值运算符，析构函数，且类的每个非静态数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。

noexcept:不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。因为某些标准库容器除非知道移动操作是无异常的，否则就会进行拷贝。

### 4.可以定义为成员或非成员函数

定义成成员函数时第一个操作数隐式绑定到this指针

### 5.不可重载的操作符有哪些？

（?:，::）

## 8.析构函数相关

### 1.销毁过程的理解

（delete会执行哪些操作？逆序析构成员）

析构函数则是释放对象使用的资源，并销毁对象的非static数据成员。成员按照初始化顺序的逆序销毁，析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。内置类型没有析构函数，因此，销毁内置类型成员什么也不需要做。所以销毁一个内置指针类型的成员需要我们手动delete

delete的操作：1.调用析构函数，释放对象中的成员资源

​        2.归还对象空间（free）

# 四、内存

## 1.c++内存分区

c++编译器将计算机内存分为 **代码区和数据区**；
**数据区又分为静态数据区、动态数据区以及常量区**，动态数据区包括堆区和栈区。

**解释：**
**栈**:存放函数参数以及局部变量,在出作用域时,将自动被释放.栈内存分配运算内置于处理器的指令集中,效率很高,但分配的内存容量有限.

**堆**:new分配的内存块(包括数组,类实例等),需delete手动释放.如果未释放,在整个程序结束后,OS会帮你回收掉.

**自由存储区**:malloc分配的内存块,需free手动释放.它和堆有些相似.

**全局/静态区**:全局变量(global)和静态变量(static)存于此处.(在以前的C语言中,全局变量又分为初始化的和未初始化的,C++不分)

**常量存储区**:常量(const)存于此处,此存储区不可修改.

## 2.new和malloc的区别？

（函数，运算符、类型安全、计算空间、步骤，operator new的实现）

**0.属性：**new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。

**1.申请内存所在的位置：**new是自由存储区，malloc是在堆上，自由存储区可以使堆，也可以是静态存储区，取决于operator new的实现细节，new甚至不为对象分配内存！

**2.返回类型安全性：**new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

**3.内存分配失败时的返回值：**new内存分配失败时，会抛出**bac_alloc异常**，它**不会返回NULL**；malloc分配内存失败时返回NULL。

**4.是否需要制定内存大小：**使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

**5.是否调用构造/析构函数：**使用new操作符来分配对象内存时会经历三个步骤：
		第一步：调用operator new 函数（对于数组是operator new[]）**分配一块足够大的**，原始的，未命名的内存空间以便存储特定类型的对象。
		第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
		第三步：对象构造完成后，**返回**一个指向该对象的**指针**。
使用delete操作符来释放对象内存时会经历两个步骤：
		第一步：调用对象的析构函数。
		第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。
总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。

**6.对数组的处理：**C++提供了new[]与delete[]来专门处理数组类型，至于malloc，如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：

**operator new的实现**：

```c++
extern void* operator new(size_t size)
{
    if(size == 0)
        size = 1;

    void *last_alloc;
    while(!(last_alloc = malloc(size))){
        if(_new_handler)
            (*_new_handler)();
        else
            return 0;
    }
    return last_alloc;
}
```

**[operator new和new operator](https://www.cnblogs.com/jamesmile/archive/2010/04/17/1714311.html)**的区别。

## 3.new[]与delete[]？

（步骤：如何分配内存，构建对象、如何析构与释放内存？构造与析构）

# 五、STL

## 1.顺序容器和关联容器

容器定义：在数据存储上，有一种对象类型，它可以持有其它对象或指向其它对象的指针，这种对象类型就叫做容器。容器就是保存其他对象的对象，还包含了一系列处理其他对象的方法，另一个特点是自行扩展。

通用容器分三类：**顺序性容器、关联式容器和容器适配器。**

顺序容器：各元素之间有顺序关系的线性表，是一种线性结构的可序群集，每个元素都有固定的位置，除非插入删除改变这个位置。

关联容器：是非线性的树结构，更准确的说是二叉树结构，各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。另一个显著的特点是它是以键值的方式来保存数据，就是说它能把关键字和值关联起来保存。

容器适配器：是一个比较抽象的概念， C++的解释是：适配器是使一事物的行为类似于另一事物的行为的一种机制。容器适配器是让一种已存在的容器类型采用另一种不同的抽象类型的工作方式来实现的一种机制。其实仅是发生了接口转换。那么你可以把它理解为容器的容器，它实质还是一个容器，只是他不依赖于具体的标准容器类型，可以理解是容器的模版。或者把它理解为容器的接口，而适配器具体采用哪种容器类型去实现，在定义适配器的时候可以由你决定。

**序列容器：**

双端deque：它允许较为快速地随机访问，但它不像vector 把所有的对象保存在一块连续的内存块，而是采用多个连续的存储块，并且在一个映射结构中保存对这些块及其顺序的跟踪，deque 是对vector 和list 优缺点的结合，它是处于两者之间的一种容器。

**关联容器：**map和set底层实现都是红黑树，所有的键值都是自动排序，不能通过迭代器来改变键的值。

**容器适配器：**

STL 中包含三种适配器：栈stack 、队列queue 和优先级priority_queue 。适配器是容器的接口，它本身不能直接保存元素，它保存元素的机制是调用另一种顺序容器去实现，即可以把适配器看作“它保存一个容器，这个容器再保存所有元素”。默认下stack 和queue 基于deque 容器实现，priority_queue 则基于vector 容器实现。

## 2.为什么要有迭代器

1.可以避免许多错误，同时还能隐藏容器的具体实现。
2.迭代器可以保证对所有容器的基本遍历方式，都是一样的，实现算法时若需要遍历，则使用迭代器，则可以不用关注容器的具体类型，实现数据结构和算法的分离。
3.迭代器模式?

## 3.vector底层实现

((迭代器类型为**随机迭代器**）？insert具体做了哪些事？resize()调用的是什么？)

底层用**数组实现**，超过当前的容量，容量就会自己扩充两倍，容量扩张步骤：重新配置，元素移动，释放原空间。
**元素连续存放**,在中间或者开始处添加或者删除元素会移动内存，如果元素时类或者结构体还会调用构造析构函数，性能不高，最好是将对象指针放入vector里

**插入和删除操作可能造成vector的3个指针重新配置，导致原有的迭代器全部失效**

**resize调用的是什么？**

```c++
void resize(size_type new_size, const T& x) {
    if (new_size < size()) 
      erase(begin() + new_size, end());
    else
      insert(end(), new_size - size(), x);
  }
void resize(size_type new_size) { resize(new_size, T()); }
```

## 4.vector的push_back要注意什么

（大量调用会伴随大量的拷贝构造与析构，内存分配与释放）

## 5.vector的resize()与reserve()

resize：上面讲过

reverse：预分配n个元素的存储空间。要和capacity和size分清楚，reserve只能增大不能减小？

```c++
  void reserve(size_type n) {
    if (capacity() < n) {
      const size_type old_size = size();
      iterator tmp = allocate_and_copy(n, start, finish);
      destroy(start, finish);
      deallocate();
      start = tmp;
      finish = tmp + old_size;
      end_of_storage = start + n;
    }
  }
```

## 6.如何释放vector的空间？容器的元素类型为指针？

**如何释放？**swap技法

vector的内存占用空间只会增大不会减小，比如你首先分配了10,000个字节，然后erase掉后面9,999个，则虽然有效元素只有一个，但是内存占用仍为10,000个，所有空间在vector析构时回收。用clear()无法保证内存回收。但是**swap技法**可以。

```c++
vector<int> nums;
nums.push_back(1);nums.push_back(1);nums.push_back(2);nums.push_back(2);
vector<int>().swap(nums);//或者nums.swap(vector<int>())；

//或者如下所示 加一对大括号都可以，意思一样的：  
{
	std::vector<int> tmp =   nums;   
	nums.swap(tmp);
} 
```

加一对大括号是可以让tmp退出{}的时候自动析构

**swap技法就是通过交换函数swap（），使得vector离开其自身的作用域，从而强制释放vector所占的内存空间**

**当元素类型为指针？**（会有内存泄露，指针是trivial_destructor；也可以使用智能指针来管理）

```c++
//在程序退出时或其它你认为适当的时候，执行如下代码：
for (vector<void *>::iterator it = g_vPtrManager.begin(); it != g_vPtrManager.end(); it ++)
{
	if (NULL != *it)
	{
			delete *it;
	*it = NULL;
	}
}
v.clear();

//remark:若你的程序是多线程的，注意一下线程安全问题，必要时加个临界区控制一下。
```

如果是trivial_destructor， 那么什么都不做。否则一一析构。

## 7.vector的clear()和deque的clear()

（vector的erase和clear**只会析构不会释放内存**，deque的erase和clear不但会析构，还可能会释放缓冲区)
deque的头尾都有缓冲区